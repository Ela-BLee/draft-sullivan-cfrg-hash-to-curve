<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.8 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-irtf-cfrg-hash-to-curve-00" category="info">

  <front>
    <title abbrev="hash-to-curve">Hashing to Elliptic Curves</title>

    <author initials="N." surname="Sullivan" fullname="Nick Sullivan">
      <organization>Cloudflare</organization>
      <address>
        <postal>
          <street>101 Townsend St</street>
          <city>San Francisco</city>
          <country>United States of America</country>
        </postal>
        <email>nick@cloudflare.com</email>
      </address>
    </author>
    <author initials="C.A." surname="Wood" fullname="Christopher A. Wood">
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>One Apple Park Way</street>
          <city>Cupertino, California 95014</city>
          <country>United States of America</country>
        </postal>
        <email>cawood@apple.com</email>
      </address>
    </author>

    <date year="2018" month="March" day="23"/>

    
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document specifies a number of algorithms that may be used to hash arbitrary
strings to Elliptic Curves.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Many cryptographic protocols require a procedure which maps arbitrary input, e.g.,
passwords, to points on an elliptic curve (EC). Prominent examples include
Simple Password Exponential Key Exchange <xref target="Jablon96"/>, Password Authenticated 
Key Exchange <xref target="BMP00"/>, and Boneh-Lynn-Shacham signatures <xref target="BLS01"/>.</t>

<t>Let E be an elliptic curve over base field GF(p). In practice, efficient
(polynomial-time) functions that hash arbitrary input to E can be constructed
by composing a cryptographically secure hash function F1 : {0,1}^* -&gt;GF(p)
and an injection F2 : GF(p) -&gt; E, i.e., Hash(m) = F2(F1(m)).
Probabilistic constructions of Hash, e.g., the MapToGroup function described by Boneh et al.
<xref target="BLS01"/>. Their algorithm fails with probability 2^I, where I is a tunable parameter
that one can control. Another variant, dubbed the “Try and Increment” approach,
was described by Boneh et al. <xref target="BLS01"/>. This function works by hashing 
input m using a standard hash function, e.g., SHA256, and then checking to see 
if the resulting point E(m, f(m)), for curve function f, belongs on E.
This algorithm is expected to find a valid curve point after approximately two 
attempts, i.e., when ctr=1, on average. (See Appendix <xref target="try"/> for a more detailed
description of this algorithm.) Since the running time of the algorithm depends on m, 
this algorithm is NOT safe for cases sensitive to timing side channel attacks. 
Deterministic algorithms are needed in such cases where failures 
are undesirable. Shallue and Woestijne <xref target="SWU"/> first introduced a deterministic 
algorithm that maps elements in F_{q} to an EC in time O(log^4 q), where q = p^n for 
some prime p, and time O(log^3 q) when q = 3 mod 4. Icart introduced yet another
deterministic algorithm which maps F_{q} to any EC where q = 2 mod 3 in time O(log^3 q) <xref target="Icart09"/>.
Elligator (2) <xref target="Elligator2"/> is yet another deterministic algorithm for any odd-characteristic 
EC that has a point of order 2. Elligator2 can be applied to Curve25519 and Curve448, which 
are both CFRG-recommended curves <xref target="RFC7748"/>.</t>

<t>This document specifies several algorithms for deterministically hashing onto a curve
with varying properties: Icart, SWU, Simplified SWU, and Elligator2. 
Each algorithm conforms to a common  interface, i.e., it maps an element from 
a base field F to a curve E. For each variant, we 
describe the requirements for F and E to make it work. Sample code for each variant is 
presented in the appendix.  Unless otherwise stated, all elliptic curve points are assumed to 
be represented as affine coordinates, i.e., (x, y) points on a curve.</t>

<section anchor="requirements" title="Requirements">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
</section>
<section anchor="algorithm-recommendations" title="Algorithm Recommendations">

<t>The following table lists recommended algorithms to use for specific curves.</t>

<texttable>
      <ttcol align='left'>Curve</ttcol>
      <ttcol align='left'>Algorithm</ttcol>
      <c>P-256</c>
      <c>SWU <xref target="simple-swu"/></c>
      <c>P-384</c>
      <c>Icart <xref target="icart"/></c>
      <c>Curve25519</c>
      <c>Elligator2 <xref target="elligator2"/></c>
      <c>Curve448</c>
      <c>Elligator2 <xref target="elligator2"/></c>
</texttable>

<t>The SWU variant from Section <xref target="swu"/> applies to any curve. As such, this algorithm
SHOULD be used if no other better alternative is known. More efficient variants and
their curve requirements are shown in the table below. These MAY be used if the target
curve meets the listed criteria.</t>

<texttable>
      <ttcol align='left'>Algorithm</ttcol>
      <ttcol align='left'>Requirement</ttcol>
      <c>Icart <xref target="icart"/></c>
      <c>p = 2 mod 3</c>
      <c>SWU <xref target="swu"/></c>
      <c>None</c>
      <c>Simplified SWU <xref target="simple-swu"/></c>
      <c>p = 3 mod 4</c>
      <c>Elligator2 <xref target="elligator2"/></c>
      <c>p is large and there is a point of order two and j-invariant != 1728</c>
</texttable>

</section>
<section anchor="generic-interface" title="Generic Interface">

<t>The generic interface for hashing to elliptic curves is as follows:</t>

<figure><artwork><![CDATA[
hash_to_curve(alpha)
]]></artwork></figure>

<t>where alpha is a message to hash onto a curve.</t>

<section anchor="utility-functions" title="Utility Functions">

<t>Algorithms in this document make use of utility functions described below.</t>

<t><list style="symbols">
  <t>HashToBase(x): H(x)[0:log2(p) + 1], i.e., hash-truncate-reduce, where 
H is a cryptographic hash function, such as SHA256, and p is the prime order 
of base field Fp.</t>
  <t>CMOV(a, b, c): If c = 1, return a, else return b.</t>
</list></t>

<t>Note: We assume that HashToBase maps its input to the base field uniformly. 
In practice, there may be inherent biases in p, e.g., p = 2^k - 1 will
have non-negligible bias in higher bits.</t>

<t>((TODO: expand on this problem))</t>

</section>
</section>
<section anchor="hashing-variants" title="Hashing Variants">

<section anchor="icart" title="Icart Method">

<t>The following hash_to_curve_icart(alpha) implements the Icart method from <xref target="Icart09"/>.
This algorithm works for any curve over F_{p^n}, where p^n = 2 mod 3 
(or p = 2 mod 3 and for odd n), including:</t>

<t><list style="symbols">
  <t>P384</t>
  <t>Curve1174</t>
  <t>Curve448</t>
</list></t>

<t>Unsupported curves include: P224, P256, P521, and Curve25519 since,
for each, p = 1 mod 3.</t>

<t>Mathematically, given input alpha, and A and B from E, the Icart method works 
as follows:</t>

<figure><artwork><![CDATA[
u = HashToBase(alpha)
x = (v^2 - b - (u^6 / 27))^(1/3) + (u^2 / 3)
y = ux + v
]]></artwork></figure>

<t>where v = ((3A - u^4) / 6u).</t>

<t>The following procedure implements this algorithm in a straight-line fashion.
It requires knowledge of A and B, the constants from the curve Weierstrass form.
It outputs a point with affine coordinates.</t>

<figure><artwork><![CDATA[
hash_to_curve_icart(alpha)

Input:

  alpha - value to be hashed, an octet string

Output:

  (x, y) - a point in E

Steps:

1.   u = HashToBase(alpha)   // {0,1}^* -> Fp
2.  u2 = u^2 (mod p)         // u^2
3.  t2 = u2^2 (mod p)        // u^4
4.  v1 = 3 * A (mod p)       // 3A
5.  v1 = v1 - t2 (mod p)     // 3A - u^4
6.  t1 = 6 * u (mod p)       // 6u
7.  t3 = t1 ^ (-1) (mod p)   // modular inverse
8.   v = v1 * t3 (mod p)     // (3A - u^4)/(6u)
9.   x = v^2 (mod p)         // v^2
10.  x = x - B (mod p)       // v^2 - b
11. t1 = 27 ^ (-1) (mod p)   // 1/27
12. t1 = t1 * u2 (mod p)     // u^4 / 27
13. t1 = t1 * t2 (mod p)     // u^6 / 27
14.  x = x - t1 (mod p)      // v^2 - b - u^6/27
15. t1 = (2 * p) - 1 (mod p) // 2p - 1
16. t1 = t1 / 3 (mod p)      // (2p - 1)/3
17.  x = x^t1 (mod p)        // (v^2 - b - u^6/27) ^ (1/3)
18. t2 = u2 / 3 (mod p)      // u^2 / 3
19.  x = x + t2 (mod p)      // (v^2 - b - u^6/27) ^ (1/3) + (u^2 / 3)
20.  y = u * x (mod p)       // ux
21.  y = y + v (mod p)       // ux + v
22. Output (x, y)

]]></artwork></figure>

</section>
<section anchor="swu" title="Shallue-Woestijne-Ulas Method">

<t>((TODO: write this section))</t>

</section>
<section anchor="simple-swu" title="Simplified SWU Method">

<t>The following hash_to_curve_simple_swu(alpha) implements the simplfied
Shallue-Woestijne-Ulas algorithm from <xref target="SimpleSWU"/>. This algorithm
works for any curve over F_{p^n}, where p = 3 mod 4, including:</t>

<t><list style="symbols">
  <t>P256</t>
  <t>…</t>
</list></t>

<t>Given curve equation g(x) = x^3 + Ax + B, this algorithm works as follows:</t>

<figure><artwork><![CDATA[
1. t = HashToBase(alpha)
2. alpha = (-b / a) * (1 + (1 / (t^4 + t^2))) 
3. beta = −t^2 * alpha
4. z = t^3 * g(alpha)
5. Output (−g * alpha) * (g * beta)
]]></artwork></figure>

<t>The following procedure implements this algorithm. It outputs a point with
affine coordinates.</t>

<figure><artwork><![CDATA[
hash_to_curve_simple_swu(alpha)

Input:

  alpha - value to be hashed, an octet string

Output:

  (x, y) - a point in E

Steps:

1.     t = HashToBase(alpha)
2. alpha = t^2 (mod p)
3. alpha = alpha * -1 (mod p)
4. right = alpha^2 + alpha (mod p)
5. right = right^(-1) (mod p)
6. right = right + 1 (mod p)
7.  left = B * -1 (mod p)
8.  left = left / A (mod p) 
9.    x2 = left * right (mod p)
10.   x3 = alpha * x2 (mod p)
11.   h2 = x2 ^ 3 (mod p)
12.   i2 = x2 * A (mod p)
13.   i2 = i2 + B (mod p)
14.   h2 = h2 + i2 (mod p)
15.   h3 = x3 ^ 3 (mod p)
16.   i3 = x3 * A (mod p)
17.   i3 = i3 + B (mod p)
18.   h3 = h3 + i3 (mod p)
19.   y1 = h2 ^ ((p + 1) // 4) (mod p)
20.   y2 = h3 ^ ((p + 1) // 4) (mod p)
21.    e = (y1 ^ 2 == h2)
22.    x = CMOV(x2, x3, e)    // If e = 1, choose x2, else choose x3
23.    y = CMOV(y1, y2, e)    // If e = 1, choose y1, else choose y2
24. Output (x, y)
]]></artwork></figure>

</section>
<section anchor="elligator2" title="Elligator2 Method">

<t>The following hash_to_curve_elligator2(alpha) implements the Elligator2
method from <xref target="Elligator2"/>. This algorithm works for any curve
with a point of order 2 and j-invariant != 1728. Given curve equation 
f(x) = y^2 = x(x^2 + Ax + B), i.e., a Montgomery form with the point of 
order 2 at (0,0), this algorithm works as shown below. (Note that any curve 
with a point of order 2 is isomorphic to this representation.)</t>

<figure><artwork><![CDATA[
1. r = HashToBase(alpha)
2. If f(-A/(1+ur^2)) is square, then output f(-A/(1+ur^2))^(1/2)
3. Else, output f(-Aur^2/(1+ur^2))^(1/2)
]]></artwork></figure>

<t>Another way to express this algorithm is as follows:</t>

<figure><artwork><![CDATA[
1. r = HashToBase(alpha)
2. d = -A / (1 + ur^2)
3. e = f(d)^((p-1)/2)
4. u = ed - (1 - e)A/u
]]></artwork></figure>

<t>Here, e is the Legendre symbol of y = (d^3 + Ad^2 + d), which will be
1 if y is a quadratic residue (square) mod p, and -1 otherwise.
(Note that raising y to ((p -1) / 2) is a common way to compute
the Legendre symbol.)</t>

<t>The following procedure implements this algorithm.</t>

<figure><artwork><![CDATA[
hash_to_curve_elligator2(alpha)

Input:

  alpha - value to be hashed, an octet string

  u - fixed non-square value in Fp.
  f() - Curve function

Output:

  (x, y) - a point in E

Steps:

1.   r = HashToBase(alpha)
2.   r = r^2 (mod p) 
3.  nu = r * u (mod p)
4.   r = nu
5.   r = r + 1 (mod p) 
6.   r = r^(-1) (mod p) 
7.   v = A * r (mod p) 
8.   v = v * -1 (mod p)   // -A / (1 + ur^2)
9.  v2 = v^2 (mod p)
10. v3 = v * v2 (mod p)
11.  e = v3 * v (mod p)
12. v2 = v2 * A (mod p)
13.  e = v2 * e (mod p)
14.  e = e^((p - 1) / 2)  // Legendre symbol
15. nv = v * -1 (mod p)
16.  v = CMOV(v, nv, e)   // If e = 1, choose v, else choose nv
17. v2 = CMOV(0, A, e)    // If e = 1, choose 0, else choose A
18.  u = v - v2 (mod p)
19. Output (u, f(u))
]]></artwork></figure>

<t>Elligator2 can be simplified with projective coordinates.</t>

<t>((TODO: write this variant))</t>

</section>
</section>
<section anchor="curve-transformations" title="Curve Transformations">

<t>((TODO: write this section))</t>

</section>
<section anchor="cost-comparison" title="Cost Comparison">

<t>The following table summarizes the cost of each hash_to_curve variant. We express this cost in 
terms of additions (A), multiplications (M), squares (SQ), and square roots (SR).</t>

<t>((TODO: finish this section))</t>

<texttable>
      <ttcol align='left'>Algorithm</ttcol>
      <ttcol align='left'>Cost (Operations)</ttcol>
      <c>hash_to_curve_icart</c>
      <c>TODO</c>
      <c>hash_to_curve_swu</c>
      <c>TODO</c>
      <c>hash_to_curve_simple_swu</c>
      <c>TODO</c>
      <c>hash_to_curve_elligator2</c>
      <c>TODO</c>
</texttable>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no IANA actions.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>Each hash function variant accepts arbitrary input and maps it to a pseudorandom
point on the curve. Points are close to indistinguishable from randomly chosen 
elements on the curve. Some variants variants are not full-domain hashes. Elligator2,
for example, only maps strings to “about half of all curve points,” whereas Icart’s
method only covers about 5/8 of the points.</t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to thank Adam Langley for this detailed writeup up Elligator2 with
Curve25519 <xref target="ElligatorAGL"/>. We also thank Sean Devlin and Thomas Icart for feedback on 
earlier versions of this document.</t>

</section>
<section anchor="contributors" title="Contributors">

<t><list style="symbols">
  <t>Sharon Goldberg <vspace />
Boston University <vspace />
goldbe@cs.bu.edu</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7748" target='https://www.rfc-editor.org/info/rfc7748'>
<front>
<title>Elliptic Curves for Security</title>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='M.' surname='Hamburg' fullname='M. Hamburg'><organization /></author>
<author initials='S.' surname='Turner' fullname='S. Turner'><organization /></author>
<date year='2016' month='January' />
<abstract><t>This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS).  These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties.</t></abstract>
</front>
<seriesInfo name='RFC' value='7748'/>
<seriesInfo name='DOI' value='10.17487/RFC7748'/>
</reference>



<reference  anchor="RFC8017" target='https://www.rfc-editor.org/info/rfc8017'>
<front>
<title>PKCS #1: RSA Cryptography Specifications Version 2.2</title>
<author initials='K.' surname='Moriarty' fullname='K. Moriarty' role='editor'><organization /></author>
<author initials='B.' surname='Kaliski' fullname='B. Kaliski'><organization /></author>
<author initials='J.' surname='Jonsson' fullname='J. Jonsson'><organization /></author>
<author initials='A.' surname='Rusch' fullname='A. Rusch'><organization /></author>
<date year='2016' month='November' />
<abstract><t>This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm, covering cryptographic primitives, encryption schemes, signature schemes with appendix, and ASN.1 syntax for representing keys and for identifying the schemes.</t><t>This document represents a republication of PKCS #1 v2.2 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series.  By publishing this RFC, change control is transferred to the IETF.</t><t>This document also obsoletes RFC 3447.</t></abstract>
</front>
<seriesInfo name='RFC' value='8017'/>
<seriesInfo name='DOI' value='10.17487/RFC8017'/>
</reference>



<reference  anchor="RFC8032" target='https://www.rfc-editor.org/info/rfc8032'>
<front>
<title>Edwards-Curve Digital Signature Algorithm (EdDSA)</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'><organization /></author>
<author initials='I.' surname='Liusvaara' fullname='I. Liusvaara'><organization /></author>
<date year='2017' month='January' />
<abstract><t>This document describes elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA).  The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves.  An example implementation and test vectors are provided.</t></abstract>
</front>
<seriesInfo name='RFC' value='8032'/>
<seriesInfo name='DOI' value='10.17487/RFC8032'/>
</reference>


<reference anchor="SECG1" target="http://www.secg.org/sec1-v2.pdf">
  <front>
    <title>SEC 1 -- Elliptic Curve Cryptography</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="Icart09" target="https://eprint.iacr.org/2009/226.pdf">
  <front>
    <title>How to Hash into Elliptic Curves</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="BLS01" target="https://iacr.org/archive/asiacrypt2001/22480516.pdf">
  <front>
    <title>Short signatures from the Weil pairing</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="BMP00" >
  <front>
    <title>Provably secure password-authenticated key exchange using diffie-hellman</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="Jablon96" >
  <front>
    <title>Strong password-only authenticated key exchange</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ElligatorAGL" target="https://www.imperialviolet.org/2013/12/25/elligator.html">
  <front>
    <title>Implementing Elligator for Curve25519</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ECOPRF" >
  <front>
    <title>EC-OPRF - Oblivious Pseudorandom Functions using Elliptic Curves</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="Elligator2" target="https://dl.acm.org/ft_gateway.cfm?id=2516734&amp;type=pdf">
  <front>
    <title>Elligator -- Elliptic-curve points indistinguishable from uniform random strings</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="SWU" target="https://arxiv.org/pdf/0706.1448">
  <front>
    <title>Rational points on certain hyperelliptic curves over finite fields</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="SimpleSWU" >
  <front>
    <title>Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>


    </references>



<section anchor="try" title="Try-and-Increment Method">

<t>In cases where constant time execution is not required, the so-called
try-and-increment method may be appropriate. As discussion in Section <xref target="introduction"/>,
this variant works by hashing input m using a standard hash function (“Hash”), e.g., SHA256, and 
then checking to see if the resulting point E(m, f(m)), for curve function f, belongs on E.
This is detailed below.</t>

<figure><artwork><![CDATA[
1. ctr = 0
3. h = "INVALID"
4. While h is "INVALID" or h is EC point at infinity:
   A.  CTR = I2OSP(ctr, 4)
   B.  ctr = ctr + 1
   C.  attempted_hash = Hash(m || CTR)
   D.  h = RS2ECP(attempted_hash)
   E.  If h is not "INVALID" and cofactor > 1, set h = h^cofactor
5. Output h
]]></artwork></figure>

<t>I2OSP is a function that converts a nonnegative integer to octet string as 
defined in Section 4.1 of <xref target="RFC8017"/>, and RS2ECP is a function that converts of a random 
2n-octet string to an EC point as specified in Section 5.1.3 of <xref target="RFC8032"/>.</t>

</section>
<section anchor="sample-code" title="Sample Code">

<section anchor="icart-method" title="Icart Method">

<t>The following Sage program implements hash_to_curve_icart(alpha) for P-384.</t>

<figure><artwork><![CDATA[
p = 394020061963944792122790401001436138050797392704654466679482934042 \
45721771496870329047266088258938001861606973112319
F = GF(p)
A = p - 3
B = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875a \
c656398d8a2ed19d2a85c8edd3ec2aef
q = 394020061963944792122790401001436138050797392704654466679469052796 \
27659399113263569398956308152294913554433653942643
E = EllipticCurve([F(A), F(B)])
g = E(0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a \
385502f25dbf55296c3a545e3872760ab7, \
    0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c0 \
0a60b1ce1d7e819d7a431d7c90ea0e5f)
E.set_order(q)

def icart(u):
  u = F(u)
  v = (3*A - u^4)//(6*u)
  x = (v^2 - B - u^6/27)^((2*p-1)//3) + u^2/3
  y = u*x + v
  return E(x, y) 

def icart_straight(u):
    u = F(u)
    u2 = u ^ 2
    t2 = u2 ^ 2
    assert t2 == u^4

    v1 = 3 * A
    v1 = v1 - t2
    t1 = 6 * u
    t3 = t1 ^ (-1)
    v = v1 * t3
    assert v == (3 * A - u^4) // (6 * u)

    x = v ^ 2
    x = x - B
    assert x == (v^2 - B)

    t1 = F(27) ^ (-1)
    t1 = t1 * u2
    t1 = t1 * t2
    assert t1 == ((u^6) / 27)
    
    x = x - t1
    t1 = (2 * p) - 1
    t1 = t1 / 3
    assert t1 == ((2*p) - 1) / 3

    x = x ^ t1
    
    t2 = u2 / 3
    x = x + t2
    y = u * x
    y = y + v
    return E(x, y)
]]></artwork></figure>

</section>
<section anchor="shallue-woestijne-ulas-method" title="Shallue-Woestijne-Ulas Method">

<t>((TODO: write this section))</t>

</section>
<section anchor="simplified-swu-method" title="Simplified SWU Method">

<t>The following Sage program implements hash_to_curve_swu(alpha) for P-256.</t>

<figure><artwork><![CDATA[
p = 115792089210356248762697446949407573530086143415290314195533631308 \
867097853951
F = GF(p)
A = F(p - 3)
B = F(ZZ("5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2 \
604b", 16))
E = EllipticCurve([A, B])

def simple_swu(alpha):
    t = F(alpha)
    
    alpha = -(t^2)
    frac = (1 / (alpha^2 + alpha))
    x2 = (-B / A) * (1 + frac)
    
    x3 = alpha * x2
    h2 = x2^3 + A * x2 + B
    h3 = x3^3 + A * x3 + B

    if is_square(h2):
        return E(x2, h2^((p + 1) // 4))
    else:
        return E(x3, h3^((p + 1) // 4))

def simple_swu_straight(alpha):
    t = F(alpha)
    
    alpha = t^2
    alpha = alpha * -1
    
    right = alpha^2 + alpha
    right = right^(-1)
    right = right + 1

    left = B * -1
    left = left / A

    x2 = left * right
    x3 = alpha * x2

    h2 = x2 ^ 3
    i2 = x2 * A
    i2 = i2 + B
    h2 = h2 + i2

    h3 = x3 ^ 3
    i3 = x3 * A
    i3 = i3 + B
    h3 = h3 + i3

    y1 = h2^((p + 1) // 4)
    y2 = h3^((p + 1) // 4)

    # Is it square?
    e = y1^2 == h2

    x = x2
    if e != 1:
        x = x3
    
    y = y1
    if e != 1:
        y = y2

    return E(x, y)
]]></artwork></figure>

</section>
<section anchor="elligator2-method" title="Elligator2 Method">

<t>The following Sage program implements hash_to_curve_elligator2(alpha) for Curve25519.</t>

<figure><artwork><![CDATA[
p = 2**255 - 19
F = GF(p)
A = 486662
B = 1
E = EllipticCurve(F, [0, A, 0, 1, 0])

def curve25519(x):
    return x^3 + (A * x^2) + x

def elligator2(alpha):

    r = F(alpha)

    # u is a fixed nonsquare value, eg -1 if p==3 mod 4.
    u = F(2) # F(2)
    assert(not u.is_square())
    
    # If f(-A/(1+ur^2)) is square, return its square root.
    # Else, return the square root of f(-Aur^2/(1+ur^2)).
    x = -A / (1 + (u * r^2))
    y = curve25519(x)
    if y.is_square(): # is this point square?
        y = y.square_root()
    else:
        x = (-A * u * r^2) / (1 + (u * r^2))
        y = curve25519(x).square_root()
    
    return (x, curve25519(x))

def elligator2_straight(alpha):
    r = F(alpha)

    r = r^2
    r = r * 2
    r = r + 1
    r = r^(-1)
    v = A * r
    v = v * -1 # d

    v2 = v^2
    v3 = v * v2
    e = v3 + v
    v2 = v2 * A
    e = v2 + e

    # Legendre symbol
    e = e^((p - 1) / 2)

    nv = v * -1
    if e != 1:
        v = nv

    v2 = 0
    if e != 1:
        v2 = A
    
    u = v - v2
    
    return (u, curve25519(u))
]]></artwork></figure>

</section>
</section>


  </back>

<!-- ##markdown-source:
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
B/MYWYNNNdFXwvp7AaPqtgGySio6EXYpdSlSIuNrxVGz4N7J5TnZg7zq2Tzr
lCxSpVBKfwaorweydQ+Enl5efddykbB3hAdCL+bCg+0gjwYe5glAHcVCmMri
6wzcvY0zeSy+LyKHSkkqhlUQDTj70/UnUVLbWR+Fh1too1HqKtvTZxlBtORz
NjELOJOFVtZF5cJucv9BdIWFCi4MYR4bOl+JupFcwLoDdmLMo1nLYMHgAZJA
fat1d/Xq6pgqEJJUrHVNJSCCfrtNhlwc6n2nMYRtRjnrpcyWcKuPz5XP7sJ+
w0zf8xhtrCIo+lBKM2q5lVqOYbORSu6UTKrUK3LD2uEBklYkzZ8Ki6EEukIQ
o4UJdUghjmkRJJciQuatDk5A+DEZ7TVCB5kErW5Zo/Iznasa76I0X6/jJKsS
Qn3sciyubbvfwb9kftcD2+pUGaYKNymVTx2jSGmUAi1FFLlkdRZNqWFHLADt
kbYfFp9acaqOXpS4zjr7clRiMvbQI8d2NZfU8PGIp63NvQ0zmuF/rfx+KI6E
PWq371vWkUN+imc2njltY4vB+SMebeqws6ElWs4U0/P7fhtDh3m7t2sV1XFY
wwiatWHE9XriwlqzbkhJ15zMMI56xkVWRC0V7VCxLhiMtECUJPjohENeeXlB
Gcr3MpAJLZ2yCa14wTjPIN0K5jnz3s/2egfgt2HXBlwYCx3T6bkC4S6V8nmR
XdFMTkJRWKOUyXTnyzCumACep1PJbkkMhHFmGLeZXJMGLSS34qAK8fzoqHYc
BVAzUACI3CZtQXUtMrF1uzimpdF4bMDoRMZj7P1BPKZvoKIUG4sD6QsIujkI
Y5ypMSiG4J8uLVgfxEOUXRhD2o8GDrFWvr/WMDdGNMTBEIy7F62u1a4NwxB8
zhGlIRo6Y5bGmISyUXu/oJk7e1dGedSCTRoTGk8WvzksFjw2LLOnxjxi6sk+
mdpXDAsaYXbs0UFarSN7ZFi2HpQRgfmecEAae5thOfWB+1Is3NKw+jXyMLhB
X0Uesz1kEgZ65ZaNlekwUlSzMMFe0xPDGlYEQGl767bUuPaRY1ijgoT7XQLU
0F0a2iQgAhPDgsa0zR3cRSONYU1KLr/alcbnt2jglU26ZNAC64/7uswfDdvS
Q7YEa4eGMNzZUKRyVu2oChIoJurDo255cNSltloVJCkfrULuA9/NYtxLVYnA
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
BqpOwb5W8oZWin7B/wBgTE8mxU4AAA==

-->

</rfc>

